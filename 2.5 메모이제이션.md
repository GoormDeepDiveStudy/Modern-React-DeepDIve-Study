
# ⚙️React 메모이제이션

리액트 API중 useMemo, useCallback훅, 고차 컴포넌트인 memo는 리액트에서 발생하는 렌더링을 최소한으로 줄이기 위해서 제공된다.

## **메모이제이션이란?**

- 함수의 결과를 캐싱하여 동일한 입력 값으로 호출될 때 기존 결과를 재사용하는 최적화 기법.
- 연산 비용이 높은 함수의 반복적인 호출을 피하고 프로그램의 실행 속도를 향상시킬 수 있다.
- 메모이제이션이 사용되는 예
    - 피보나치 수열
    - DFS/BFS 탐색
    - 동적 프로그래밍
    - 경로 찾기
- 메모이제이션의 장점 : 성능 향상과 최적화 가능
- 메모이제이션의 단점 : 메모리 사용 증가와 함수의 순수성 제한
    - 메모이제이션으로 인해 함수가 캐시 상태를 갖게 되어, 함수가 순수 함수의 성질을 잃을 수 있다.

**공통 전제 : 일부 컴포넌트에서는 메모이제이션을 하는 것이 성능에 도움이 된다.**

# **⚠️주장 1: 섣부른 최적화는 독이다. 꼭 필요한 곳에만 메모이제이션을 추가하자.**

**메모이제이션도 어디까지나 비용이 드는 작업이므로 최적화에 대한 비용을 지불할 때는 항상 신중해야 한다.**

예시코드

```jsx
function sum(a, b){
  return a + b
}
```

이 코드는 극단적이지만, 대부분의 가벼운 작업 자체는 메모이제이션해서 js 메모리 어딘가에 두었다가 다시 꺼내오는 것보다

매번 이 작업을 수행해 결과를 반환하는 것이 더 빠를 수도 있다.

**메모이제이션의 비용**

- 값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 작업
- 이전에 결과물을 저장해 두었다가 다시 꺼내와야 하는 작업

**이 비용이 리렌더링 비용보다 무조건 저렴하다고 할 수 없다.**

항상 메모이제이션은 신중하게 접근해야 하며 섣부른 최적화는 항상 경계해야 한다.

만약 이러한 비교와 렌더링이 문제가 되었다면,

리액트에서는 진작에 모든 컴포넌트를 PureComponents로 만들거나 memo로 감싸는 작업을 했을 것이다.

개발자에게 선택권으로 준 것은 메모이제이션이 모든 문제를 해결할 수 있는 것은 아니라는 사실을 방증한다.

**리액트 공식 문서**

> useMemo는 성능 최적화를 위해 사용할 수는 있지만 의미상으로 그것이 보장된다고 생각하지는 마세요. 가까운 미래에 리액트에서는 이전에 메모이제이션된 값들의 일부를 “잊어버리고” 다음 렌더링 시에 그것들을 재계산하는 방향을 택할지도 모르겠습니다. 예를 들면, 오프스크린 컴포넌트의 메모리를 해제하는 등이 있을 수 있습니다. useMemo를 사용하지 않고도 작동할 수 있도록 코드를 작성하고 그것을 추가해 성능을 최적화하세요.
> 

메모이제이션은 이전 결과를 캐시로 저장해 미래에 더 나은 성능을 위해 메모리를 차례대로 점유한다.

공식문서에서, 리액트는 가능한 한 오랫동안 이 캐시 결과를 저장하려고 하겠지만, 경우에 따라 무효화될 경우도 있다고 언급했으며

리액트가 useMemo를 언제까지고 성능 최적화를 위해 제공해 줄 것이라는 보장이 없다.

**따라서 섣부른 최적화는 옳지 못하다.**

애플리케이션을 어느 정도 만든 이후에 개발자 도구나 useEffect를 사용해 실제로 어떻게 렌더링이 일어나고 있는지 확인하고, 필요한 곳에서만 최적화하는 것이 옳다.

# **💸주장 2: 렌더링 과정의 비용은 비싸다. 모조리 메모이제이션해 버리자.**

섣부른 최적화 여부와 관계없이 해당 컴포넌트가

- 렌더링이 자주 발생
- 그 렌더링 사이에 비싼 연산 포함
- 자식 컴포넌트를 많이 가짐

라면, memo나 다른 메모이제이션 방법을 사용하는 것이 이점이 있을 수 있다.

**선택할 수 있는 방법**

- memo를 컴포넌트의 사용에 따라 잘 살펴보고 일부에만 적용
- memo를 일단 그냥 다 적용

첫번째 방법은 이상적인 상황이지만, 애플리케이션의 규모가 커지고, 개발자가 증가하고, 컴포넌트 복잡성이 증가하면 유지하기 어렵다.

또한 개발자들이 실무에서 최적화와 성능 향상에 쏟을 시간이 많지 않다.

**따라서 일단 memo로 감싸고 생각해보자.**

이 주장은 렌더링 비용이 저렴하거나 별로 렌더링이 안 되는 컴포넌트에 memo를 썼을 때,

역으로 지불해야 하는 비용을 고려하는 것이다.

잘못된 memo로 지불해야 하는 비용 = props에 대한 얕은 비교가 발생하면서 지불해야 하는 비용

메모이제이션을 위해 CPU와 메모리를 사용해 이전 렌더링 결과물을 저장해둬야하고,

리렌더링할 필요가 없다면 이전 결과물을 사용해야 한다.

= 리액트의 재조정 알고리즘과 같다.

**따라서 memo로 지불해야 하는 비용 = props에 대한 얕은 비교뿐**

**반면 memo를 하지 않았을 때 발생할 수 있는 문제**

- 렌더링을 함으로써 발생하는 비용
- 컴포넌트 내부의 복잡한 로직의 재실행
- 위 두가지 모두가 모든 자식 컴포넌트에서 반복
- 리액트가 구 트리와 신규 트리 비교

**useMemo와 useCallback**

- 두 훅을 사용해 의존성 배열을 비교하고, 필요에 따라 값을 재계산하는 과정
- 값과 함수를 매번 재생성하는 비용

매번 두 비용을 매번 계산해야하므로, 이 또한 무조건 메모이제이션하는 방법을 고민해보자.

리렌더링이 발생할 때 메모이제이션과 같은 별도 조치가 없다면

모든 객체는 재생성되고, 결과적으로 참조는 달라지게 된다.

이 달라진 참조 값을 어디서든 쓰지 않는다면 큰 문제가 되지 않을 수 있지만,

useEffect와 같은 **의존성 배열에 쓰이면 변경된 참조로 인해 다른 쪽에도 영향을 미칠 것**이다.

예시코드

```jsx
function useMath(number: number) {
  const [double, setDouble] = useState(0)
  const [triple, setTriple] = useState(0)

  useEffect(() => {
    setDouble(number * 2)
    setTriple(number * 3)
  }, [number])

  return { double, triple }
}

export default function App() {
  const [counter, setCounter] = useState(0)
  const value = useMath(10)

  useEffect(() => {
    console.log(value.double, value.triple)
  }, [value])//값이 실제로 변한 건 없는데 계속해서 console.log가 출력된다.
  function handleClick() {
    setCounter((prev) => prev + 1)
  }

  return (
    <>
      <h1>{counter}</h1>
      <button onClick={handleClick}>+</button>
    </>
  )
}
```

useMath 훅은 인수로 넘겨주는 값이 변하지 않는 이상, 같은 값을 가지고 있어야 하는데

handleClick으로 렌더링을 강제로 일으켜 보면 consol.log가 출력된다.

함수 컴포넌트인 App이 호출되면서 useMath가 계속해서 호출되고, 객체 내부의 값 같지만 참조가 변경되기 때문이다.

useMemo를 활용하면 이를 해결할 수 있다.

```jsx
function useMath(number: number) {
  const [double, setDouble] = useState(0)
  const [triple, setTriple] = useState(0)

  useEffect(() => {
    setDouble(number * 2)
    setTriple(number * 3)
  }, [number])

  return useMemo(()=>({ double, triple }),[double,triple])
}
```

값이 변경되지 않는 한 같은 결과물을 가질 수 있고, 참조의 투명성을 유지할 수 있게 된다.

**메모이제이션을 하지 않는 것보다 했을 때 더 많은 이점을 누릴 수 있다.**

섣부른 초기화라 할지라도 했을 때 누릴 수 있는 이점, 실수로 빠트렸을 때 치러야 할 위험비용이 더 크기때문에

최적화에 대한 확신이 없다면 가능한 한 모든 곳에 메모이제이션을 활용한 최적화를 하는 것이 좋다.

# **📝결론 및 정리**

> 아직 리액트를 배우고 있거나 혹은 리액트를 깊이 이해하고 싶고, 이를 위해 시간을 투자할 여유가 있다면 **섣부른 메모이제이션을 지양하는 자세를 견지하면서 실제 어느 지점에서 성능상 이점을 누릴 수 있는지 살펴보는 식으로 메모이제이션을 적용하는 것을 권장**한다.
> 

> 현업에서 리액트를 사용하거나 실제로 다룰 예정이지만 성능에 대해 깊게 연구해 볼 수 없는 상황이라면 일단 **의심스러운 곳에는 먼저 다 적용해 볼 것을 권장**한다.
>
